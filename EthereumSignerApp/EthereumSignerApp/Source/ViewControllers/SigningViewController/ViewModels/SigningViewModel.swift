//
//  SigningViewModel.swift
//  EthereumSignerApp
//
//  Created by Vijay Kumar on 21/06/2019.
//  Copyright Â© 2019 Vijay. All rights reserved.
//

//import GnosisQR
import web3swift

class SigningViewModel {
    ///ether service provider
    private(set) var etherServiceProvider: AbstractCryptoServiceProvider
    
    ///QR code generator
    lazy var qrGenerator: QRGenerator = GnosisQRGenerator()
    
    ///code block called when signing fails
    var onSigningFailure: ((Error) -> Void)?

    /// code block called when signing succeeds
    var onSigningSuccess: ((UIImage) -> Void)?
    
    /// Init Method
    ///
    /// - Parameter serviceProvider: service provider for signing
    init(serviceProvider: AbstractCryptoServiceProvider) {
        //set service provider
        self.etherServiceProvider = serviceProvider
    }

    /// method to tell when sign message button should be enabled
    ///
    /// - Parameter message: message being typed
    /// - Returns: true if button should be enabled, false otherwise
    func shouldEnableButton(for message: String?) -> Bool {
        guard let message = message else { return false }
        
        //enable button if message is not empty
        return !message.isEmpty
    }
    
    /// method to sign message into QRCode
    ///
    /// - Parameter message: message to be signed
    func sign(message: String) {
        //getBalance is synchronous, so start background thread
        DispatchQueue.global().async {
            do {
                //sign using service provider
                let signature = try self.etherServiceProvider.signature(of: message)
                
                //get qr image of signature
                let qrImage = try self.qrCode(of: signature)

                //call success block
                DispatchQueue.main.async {
                    self.onSigningSuccess?(qrImage)
                }
            } catch {
                //call fail block
                DispatchQueue.main.async {
                    self.onSigningFailure?(error)
                }
            }//end catch
        }//end async block
    }
    
    /// Method to encode signed message into QR. Native QR scanner provides converts scanned Data to String, and provides resulting string only. Therefore, to encode signed signature into readable string, we encode it's bytes so the resulting string from scanner can be coverted back to signature.
    ///
    /// - Parameter signature: signature generated by ether client
    /// - Returns: image of QR code as UIImage
    /// - Throws: error if any while generating QR code
    private func qrCode(of signature: Data) throws -> UIImage {
        //get comma separated bytes string of signature
        let byteString = signature.byteString(separatedBy: ",")
        
        //generate QRCode
        //var qrGenerator = GnosisQRGenerator()
        let qrImage = try qrGenerator.generateQR(for: byteString)
        
        //return QRCode image
        return qrImage
    }
}
